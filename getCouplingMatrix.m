function K = couplingmatrixsymbolic(N)

filename = ['savedCouplingMatrix/', num2str(N), '.mat'];

% if isfile(filename)
%     M = load(filename);
%     K = M.K;
% else

    % returns the three su(2) generators in the N-dim. irreducible rep. 
    [J1, J2, J3, ~, ~] = computeSu2(N);

    % Three NxN fluctuation matrices containing symbolic variables, 
    % real valued.
    syms Rx1 [N N];
    syms Rx2 [N N];
    syms Rx3 [N N];

    % Substituting in the real valued matrix elements
    x1 = computeComplexMatrixFromReal(Rx1);
    x2 = computeComplexMatrixFromReal(Rx2);
    x3 = computeComplexMatrixFromReal(Rx3);

    % returns the symbolic expression for V2 in terms of the real valued 
    % entries of fluctuation matrices
    V2 = trace(-...
        2j*J3*x1*x2 + 2j*J3*x2*x1 - 2*x1^2 + ... % cycle 1
        2*J1*x2*x2*J1 + 2*J2*x1*x1*J2 - 2*J1*x2*J1*x2 - 2*J2*x1*J2*x1 - ...
        2*x1*J2*J1*x2 - 2*J2*x1*x2*J1 + 2*J2*x1*J1*x2 + 2*x1*J2*x2*J1 - ...
        2j*J1*x2*x3 + 2j*J1*x3*x2 - 2*x2^2 + ...  % cycle 2
        2*J2*x3*x3*J2 + 2*J3*x2*x2*J3 - 2*J2*x3*J2*x3 - 2*J3*x2*J3*x2 - ...
        2*x2*J3*J2*x3 - 2*J3*x2*x3*J2 + 2*J3*x2*J2*x3 + 2*x2*J3*x3*J2 - ...
        2j*J2*x3*x1 + 2j*J2*x1*x3 - 2*x3^2 + ... % cycle 3
        2*J3*x1*x1*J3 + 2*J1*x3*x3*J1 - 2*J3*x1*J3*x1 - 2*J1*x3*J1*x3 - ...
        2*x3*J1*J3*x1 - 2*J1*x3*x1*J3 + 2*J1*x3*J3*x1 + 2*x3*J1*x1*J3);

    % generate the column vector of symbolic variables corresponding to the 
    % real valued fluctuation matrix entries. Follows the diagonal 
    % prescription for the ordering of these variables
    % Create an empty vector and iteratively append diagonals from the xi 
    % to it
    Y = computeVectorFromMatrices(Rx1, Rx2, Rx3);

    % K is the matrix for which Y.' * K * Y recovers the potential V2
    % The extra 1/2 factor is necessary. Consider the duplicate terms 
    % generated by hessian() due to symmetry of the derivatives.
    K = real(double((1/2)*hessian(V2, Y)));

    % save the results
    save(filename,'K');

end
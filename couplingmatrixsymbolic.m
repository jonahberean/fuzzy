function K = couplingmatrixsymbolic(N)
% couplingmatrixsymbolic.m - Generates coupling matrix using a symbolic
% approach
%
% Syntax:  K = couplingMatrix(N)
%
% Inputs:
%    N - coordinate matrix dimension
%
% Outputs:
%    K - coupling matrix of dimension 3N^2
%
% Other m-files required: none
% Subfunctions: none
% MAT-files required: none
%
% Author: Jonah Berean-Dutcher
% email: jbd@phas.ubc.ca
% March 2021; Last revision: 16-March-2021
%------------- BEGIN CODE --------------

    statement = '\ncouplingmatrixsymbolic for N = %d\n\n';
    fprintf(statement, N)

    % returns the three su(2) generators in the N-dim. irreducible rep. 
    [L1, L2, L3, ~, ~] = su2generators(N);

    % rescaling the su(2) generators so as to normalize the fuzzy sphere radius to 1.
    nu     = 2 / sqrt(N^2 - 1);
    L1 = nu*L1;
    L2 = nu*L2;
    L3 = nu*L3;

    % Three NxN fluctuation matrices containing symbolic variables, 
    % real valued.
    syms Rx1 [N N];
    syms Rx2 [N N];
    syms Rx3 [N N];

    % Substituting in the real valued matrix elements
    x1 = 1/2*(Rx1 + Rx1.') - 1/(2*sqrt(-1))*(Rx1 - Rx1.');
    x2 = 1/2*(Rx2 + Rx2.') - 1/(2*sqrt(-1))*(Rx2 - Rx2.');
    x3 = 1/2*(Rx3 + Rx3.') - 1/(2*sqrt(-1))*(Rx3 - Rx3.');
    
    % returns the symbolic expression for V2 in terms of the real valued 
    % entries of fluctuation matrices
    V2 = trace(-...
        2j*L3*x1*x2 + 2j*L3*x2*x1 - 2*x1^2 + ... % cycle 1
        2*L1*x2*x2*L1 + 2*L2*x1*x1*L2 - 2*L1*x2*L1*x2 - 2*L2*x1*L2*x1 - ...
        2*x1*L2*L1*x2 - 2*L2*x1*x2*L1 + 2*L2*x1*L1*x2 + 2*x1*L2*x2*L1 - ...
        2j*L1*x2*x3 + 2j*L1*x3*x2 - 2*x2^2 + ...  % cycle 2
        2*L2*x3*x3*L2 + 2*L3*x2*x2*L3 - 2*L2*x3*L2*x3 - 2*L3*x2*L3*x2 - ...
        2*x2*L3*L2*x3 - 2*L3*x2*x3*L2 + 2*L3*x2*L2*x3 + 2*x2*L3*x3*L2 - ...
        2j*L2*x3*x1 + 2j*L2*x1*x3 - 2*x3^2 + ... % cycle 3
        2*L3*x1*x1*L3 + 2*L1*x3*x3*L1 - 2*L3*x1*L3*x1 - 2*L1*x3*L1*x3 - ...
        2*x3*L1*L3*x1 - 2*L1*x3*x1*L3 + 2*L1*x3*L3*x1 + 2*x3*L1*x1*L3);
    
    % generate the column vector of symbolic variables corresponding to the 
    % real valued fluctuation matrix entries. Follows the diagonal 
    % prescription for the ordering of these variables
    % Create an empty vector and iteratively append diagonals from the xi 
    % to it
    Y = sym(zeros(1,3*N^2));

    % Append the main diagonals to Y
    Y(1:N)       = diag(Rx1);
    Y(N+1:2*N)   = diag(Rx2);
    Y(2*N+1:3*N) = diag(Rx3);

    % index of the first element after the main diagonals
    start = 3*N+1;

    % placeholder for counting indices
    step = 0;

    % Looping from 1 to N-1, the number of diagonals of a given sign i.e. 
    % upper or lower
    for i = 1:N
        start = start + step;
        Y(start           : start+(N-1-i))         = diag(Rx1, i);
        Y(start+1*(N-i)   : start+2*(N-i)-1)       = diag(Rx2, i);
        Y(start+2*(N-i)   : start+3*(N-i)-1)       = diag(Rx3, i);
        Y(start+3*(N-i)   : start+4*(N-i)-1)       = diag(Rx1, -i);
        Y(start+4*(N-i)   : start+5*(N-i)-1)       = diag(Rx2, -i);
        Y(start+5*(N-i)   : start+6*(N-i)-1)       = diag(Rx3, -i);

        step = 6*(N-i);
    end
    
    % K is the matrix for which Y.' * K * Y recovers the potential V2
    % The extra 1/2 factor is necessary. Consider the duplicate terms 
    % generated by hessian() due to symmetry of the derivatives.
    K = real(double((1/2)*hessian(V2, Y)));
    
    % save the results
    saveFilename = ['savedcouplingmatrices/', num2str(N), '.mat'];
    save(saveFilename,'K');

end